<!DOCTYPE html>
<html>
  <!DOCTYPE html>
<html lang="en">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
  
  <title>Interface Callback and Observer Pattern - Bingyang</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0">
  
  <meta name="keywords" content="Interface">
  
  
    <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=1.02">
  
  
    <link rel="alternate" href="/atom.xml " title="Bingyang" type="application/atom+xml">
  

  <link rel="stylesheet" href="/css/style.css">
</head></html>
  <body>
    <div class="container">
      <header class="header">
  <div class="blog-title">
    <a href="/" class="logo">Bingyang</a>
    <div class="subtitle">总有人把你推向阳光</div>
  </div>
  <nav class="navbar">
    <ul class="menu">
      
        <li class="menu-item">
          <a href="/" class="menu-item-link">Home</a>
        </li>
      
        <li class="menu-item">
          <a href="/archives" class="menu-item-link">Archives</a>
        </li>
      
        <li class="menu-item">
          <a href="/about" class="menu-item-link">About</a>
        </li>
      
    </ul>
  </nav>
</header>
<article class="post">
  <div class="post-title">
    <h1 class="article-title">Interface Callback and Observer Pattern</h1>
  </div>
   <div class="post-meta">
    <span class="post-time">2018-10-16</span>
  </div>
  <div class="post-content">
    <p>Callback is a very important feature in Java. For button click listener, it uses interface callback. I used to use interface callback often, but not very clearly understand it.</p>
<h4 id="Interface-and-Callback"><a href="#Interface-and-Callback" class="headerlink" title="Interface and Callback"></a>Interface and Callback</h4><p>It is very easy to define an interface. Here we define a <em>EatHelperInterface</em> interface and it has a <em>eat</em> function.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">EatHelperInterface</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>If this person is a Chinese, we just implement this interface.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Chinese</span> <span class="keyword">implements</span> <span class="title">EatHelperInterface</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"I need chopsticks to eat"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>This is how we implement an interface. Also we can define many classes for different people. However, we don’t want so many class defined. It is better to define a <em>People</em> class to keep this interface, so that we can use callback to help different people to eat.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">EatHelperInterface</span> <span class="title">eatHelperInterface</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setEatHelperInterface</span><span class="params">(EatHelperInterface eatHelperInterface)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.eatHelperInterface = eatHelperInterface;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eatService</span><span class="params">()</span></span>&#123;</span><br><span class="line">        eatHelperInterface.eat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><em>setEatHelperInterface</em> is to register the interface. <em>People.eatService()</em> is to execute the <em>eat</em> function of the interface. Our test can be like this.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        People chinese = <span class="keyword">new</span> people();</span><br><span class="line">        chinese.setEatHelperInterface(<span class="keyword">new</span> Chinese());</span><br><span class="line">        chinese.eatService();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>In many cases, we would like to use an anonymous inner class to define an interface.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        People people = <span class="keyword">new</span> people();</span><br><span class="line">        people.setEatHelperInterface(<span class="keyword">new</span> EatHelperInterface() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"I need **** to eat"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        people.eatService();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Callback can separate the class which use this function and the one implement the function. Because the they do not care about each other. For any <em>People</em>, we just use <em>people.eatService()</em> to perform <em>eat</em> action. Different people pass different implementation into the interface.</p>
<h4 id="Callback-in-Android"><a href="#Callback-in-Android" class="headerlink" title="Callback in Android"></a>Callback in Android</h4><p>In Android development, for button click function, we have an interface <em>OnClickListener</em> and <em>Button</em>(View) contains this interface.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OnClickListener</span> </span>&#123;   </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span></span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">View</span> <span class="keyword">implements</span> <span class="title">Drawable</span>.<span class="title">Callback</span>, <span class="title">KeyEvent</span>.<span class="title">Callback</span>, <span class="title">AccessibilityEventSource</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">protected</span> OnClickListener mOnClickListener;  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setOnClickListener</span><span class="params">(OnClickListener l)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">if</span> (!isClickable()) &#123;  </span><br><span class="line">            setClickable(<span class="keyword">true</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">        mOnClickListener = l;  </span><br><span class="line">    &#125;  </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">performClick</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">if</span> (mOnClickListener != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mOnClickListener.onClick(<span class="keyword">this</span>);  </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>This button that extends the view class is very similar with the People class, which contains the interface and execute its function.</p>
<p>For <em>MainActivity</em> we should ask for help how to perform this click function. We can implement the interface in <em>MainActivity</em> and pass <em>this</em> into <em>OnClickListener</em>, or we can use anonymous inner class.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span></span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> Button button; </span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);  </span><br><span class="line">        setContentView(R.layout.activity_main);  </span><br><span class="line">        button = (Button)findViewById(R.id.button1); </span><br><span class="line">        button.setOnClickListener(<span class="keyword">new</span> OnClickListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span> </span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><em>Button</em> -&gt; <em>People</em></li>
<li><em>setOnClickListener</em> -&gt; <em>setEatHeplerInterface</em></li>
<li><em>onClickListener</em> -&gt; <em>EatHelperInterface</em></li>
<li><em>onClick</em> -&gt; <em>eat</em></li>
</ul>
<p>The difference of these two cases is that <em>people.eatService()</em> called in <em>Test</em>, but for button, only case to trigger the <em>performClick</em> is when we click the button (Not showing in code).</p>
<h4 id="Observer-Pattern"><a href="#Observer-Pattern" class="headerlink" title="Observer Pattern"></a>Observer Pattern</h4><p>This is a simple Observer Pattern example. Observer A is very sensitive to some actions of observable B. A needs to do actions at the moment changes in B. Also look at the button example. When trigger <em>button.performClick</em>, <em>OnClickListener</em> need to react immediately.</p>
<p>Trigger: button Click -&gt; view.performClick -&gt; onClick</p>
<p>Hierarchy: (Button)View.setOnClickListener -&gt; OnClickListener -&gt; onClick</p>
<p>For Observer Patthern, there are <em>FOUR</em> component: Observer, subscribe, Observable, event. Observer subscribe Observable. when state of Observable changed, observer will know that(subscribe) and trigger its event based on this change.</p>
<p><img src="http://ww3.sinaimg.cn/mw1024/52eb2279jw1f2rx4446ldj20ga03p74h.jpg" alt></p>
<ul>
<li><em>Button</em> -&gt; observable</li>
<li><em>setOnClickListener</em> -&gt; subscribe</li>
<li><em>onClickListener</em> -&gt; Observer</li>
<li><em>onClick</em> -&gt; event</li>
</ul>
<p><img src="http://ww4.sinaimg.cn/mw1024/52eb2279jw1f2rx42h1wgj20fz03rglt.jpg" alt></p>
<p>For observer pattern, it is an very useful pattern and we have many needs of it.</p>
<p>In Android development, we can easily to achieve infinite loading feature by observer pattern. For a recyclerview, every time it will show 10 items with data and one more item showing loading layout. In adapter <em>onCreateViewHolder</em> and <em>onBindViewHolder</em> we should implement this way.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> RecyclerView.<span class="function">ViewHolder <span class="title">onCreateViewHolder</span><span class="params">(ViewGroup parent, <span class="keyword">int</span> viewType)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(viewType == VIEW_TYPE_SHOT) &#123;</span><br><span class="line">        View view = LayoutInflater.from(parent.getContext()).inflate(R.layout.list_item_shot, parent, <span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ShotViewHolder(view);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        View view = LayoutInflater.from(parent.getContext()).inflate(R.layout.list_item_loading, parent, <span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RecyclerView.ViewHolder(view) &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onBindViewHolder</span><span class="params">(<span class="keyword">final</span> RecyclerView.ViewHolder holder, <span class="keyword">int</span> position)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> viewType = getItemViewType(position);</span><br><span class="line">    <span class="keyword">if</span>(viewType == VIEW_TYPE_LOADING) &#123;</span><br><span class="line">        loadMoreListener.onLoadMore();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> Shot shot = data.get(position);</span><br><span class="line">        <span class="comment">// ....</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>So everytime when we scrolling to the last item which is VIEW<em>TYPE_LOADING, it will trigger _onLoadMore</em> function. It is like everytime we click button, <em>performClick</em> will triiger <em>onClick</em> function. When we setup adapter, we should implement this loadMoreListenner.onLoadmore function.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">shotListAdapter = <span class="keyword">new</span> ShotListAdapter(<span class="keyword">new</span> ArrayList&lt;Shot&gt;(), <span class="keyword">new</span> ShotListAdapter.LoadMoreListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onLoadMore</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> page = shotListAdapter.getDataCount() / COUNT_PRE_PAGE + <span class="number">1</span>;</span><br><span class="line">        AsyncTaskCompat.executeParallel(<span class="keyword">new</span> LoadShotTask(page));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>This <em>LoadShotTask</em> extends <em>AsyncTask</em> will use RESTful API to ask for next page of shots. This is a simple use of Interface Callback. The entire source code you can check from my <a href="https://github.com/bbbbyang/DribbbleApp" target="_blank" rel="noopener">Dribbble app</a>.</p>
<p>Another place to use it is that when we want to refresh the content of a fragment, while the refresh button is not inside the fragment. We need to fresh the fragment from its parent activity. We should implement the listener by the observer pattern. Here is the <a href="https://stackoverflow.com/questions/26606527/android-refresh-a-fragment-list-from-its-parent-activity" target="_blank" rel="noopener">simple example</a>.</p>
<p>Another widely used of observer pattern is the RxJava.</p>

  </div>
  <div class="post-footer">
    
      <ul class="post-tag-list"><li class="post-tag-list-item"><a class="post-tag-list-link" href="/tags/Interface/">Interface</a></li></ul>
    

    <a href="#top" class="top">Back to Top</a>
  </div>
</article>
<footer>
  &copy; 2020
  <span class="author">
    Bingyang Liu
  </span>
</footer>
    </div>
  </body>
</html>