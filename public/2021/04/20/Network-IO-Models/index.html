<!DOCTYPE html><html lang="en"><head><meta name="generator" content="Hexo 3.9.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>Network IO Models | Bingyang</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/7.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon-32.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Network IO Models</h1><a id="logo" href="/.">Bingyang</a><p class="description">总有人把你推向阳光</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> Home</i></a><a href="/archives/"><i class="fa fa-archive"> Archive</i></a><a href="/about/"><i class="fa fa-user"> About</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Network IO Models</h1><div class="post-meta">Apr 20, 2021<span> | </span><span class="category"><a href="/categories/Linux/">Linux</a></span></div><div class="post-content"><p>My recent work involved a lot of network IO stuff, like raw TCP/Multicast using Netty and websocket/UDP using Boost.asio. So I went through the NIO models to get a better idea of how it works. I will use TCP server as an example (server need to handle multiple connections). There are lots of charts illustrate these 5 IO models, but I think it is better to understand why we need these models.</p>
<p>First, we need to set up the server socket then make this socket bind with a port and listen. In linux, everything is file descriptor, so does the socket. Below is the Pseudocode.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">setup fd :</span><br><span class="line">socket fd</span><br><span class="line">bind fd 8080</span><br><span class="line">listen fd</span><br></pre></td></tr></table></figure></p>
<h5 id="Block-IO"><a href="#Block-IO" class="headerlink" title="Block IO"></a>Block IO</h5><p>Now if a client asking for connection, our server needs to accept the coming request. So we need to call the <code>accept</code> function. However, the <code>accept</code> will block the process until recevie a connection request.</p>
<p>After connection request received by server, <code>accept</code> will return a new <em>fd</em> which handles the requests from the connected client. <code>recvfrom</code> can get data from the client but it will also block the process. And we need our server to handle multiple clients, so we can use <code>while</code> for the <code>accept</code> to connect new connection and <code>recvfrom</code> for data communication. The server process will be like<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">                       app server</span><br><span class="line">                           |</span><br><span class="line">                |       setup fd       |</span><br><span class="line">                |       while(1)       |</span><br><span class="line">                |     &#123;  accept fd     |   block util connected, return fd1 </span><br><span class="line">                | recvfrom fd1,2... &#125;  |   block util first client send data</span><br><span class="line">                    |      |</span><br><span class="line">Client 1  ----------|      |----------------   Client 2</span><br></pre></td></tr></table></figure></p>
<p>This server can only accept next connection after the first connection sends data because the <code>recvfrom</code> block the process. It can not handle more than one client because of this. So we can throw a new thread to handle a connection. So accept only block in main thread waiting for new connection while each new thread for connection will block waiting for receving data.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">                    app server</span><br><span class="line">                        |</span><br><span class="line">                |     setup fd      |</span><br><span class="line">                |     while(1)      |</span><br><span class="line">                |   &#123;  accept fd    |   block util connected, return fd1 </span><br><span class="line">                |   thorw thread  &#125; | ---------|---------------------|</span><br><span class="line">                |          |                   |                     |</span><br><span class="line">Client 1  ----------|      |             | T1 recvfrom fd1 |       | T2 |</span><br><span class="line">Client 2 ------------------|</span><br></pre></td></tr></table></figure></p>
<p>Each thread will map to one client to handle that connection, and get blocked waiting for data. This model can handle thousand of connections (if we can set up OS to create enough threads). However, it exists some problems:</p>
<ul>
<li>If we have 1000 of clients, the first 999 clients didnt send any data but the 1000th client sent data. In order to get the data from that client, it needs to switch theads 1000 times and 999 switchings are useless and wasting resource.</li>
<li>Memory usage waste. Thread stack is independent.</li>
</ul>
<p>We don’t want to throw so many threads and also don’t want a blocking function. NIO will be the solution.</p>
<h5 id="None-Blocking-IO"><a href="#None-Blocking-IO" class="headerlink" title="None Blocking IO"></a>None Blocking IO</h5><p>Linux provides a NONBLOCK choice to avoid throwing threads to receive data. So we pass NONBLOCK to socket or use fcntl to set NONBLOCK type fd. When we call recvfrom/accept function if it does receive data/new connection comes, it will return the data/build connection otherwise just return. Here loop all the fds.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">                        app server</span><br><span class="line">                             |</span><br><span class="line">                |        setup fd         |</span><br><span class="line">                |        while(1)         |</span><br><span class="line">                |      &#123;  accept fd       |</span><br><span class="line">                |   recvfrom fd1,fd2..  &#125; | </span><br><span class="line">                    |      |</span><br><span class="line">Client 1  ----------|      |</span><br><span class="line">Client 2 ------------------|</span><br></pre></td></tr></table></figure></p>
<p>Now it is possible to use only one thread to handle all connections. It still has some cons:</p>
<ul>
<li>Every loop, it will call recvfrom from the linux kernel no matter it has data or not. The complexity is O(n). For N connections, if only one connection has data recevied, it will cause a lot of waste.</li>
</ul>
<p>So next improvement will be how to reduce the system call(recvfrom) if only one connection receives data? How to ignore the system call which does not have data while looping?</p>
<h5 id="Multiplexing"><a href="#Multiplexing" class="headerlink" title="Multiplexing"></a>Multiplexing</h5><blockquote>
<p><code>select</code> allow a program to monitor multiple file descriptors, waiting until one or more of the file descriptors become “ready” for some class of IO operation.</p>
</blockquote>
<p>The while loop will be like:</p>
<ol>
<li>use <code>FD_SET</code> to pass the socket fd(listen) in to fd array.</li>
<li>check the return fd array has the listen fd or not</li>
<li>if it has listen fd, call accept to build a new connection and get a connection fd.</li>
<li>pass the new connection fd into the fd array</li>
<li>check fd array has the connection fd or not</li>
<li>if it has connection fd, call recvfrom<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">                        app server</span><br><span class="line">                             |</span><br><span class="line">                |        setup fd         |</span><br><span class="line">                |        while(1)         |</span><br><span class="line">                |   &#123;  select(fd*) -&gt; num |</span><br><span class="line">                |         accept(fd)      |</span><br><span class="line">                |        recvfrom(fd*)  &#125; | </span><br><span class="line">                    |      |</span><br><span class="line">Client 1  ----------|      |</span><br><span class="line">Client 2 ------------------|</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>Everytime loop the fds, the complexity is O(1) and O(n) for recvfrom.</p>
<ul>
<li>Every loop, application needs to pass all file descriptors into select.</li>
<li>Kernel needs to loop all the fds, for kernel it is O(N)</li>
</ul>
<p>We have a <code>epoll</code> function to solve this.<br>First, <code>epoll_create</code> will create a space in kernel then <code>epoll_ctl</code> can add or delete listen fd or read/write fd in that space. If the fd is ready, kernel will pass that fd to another space. We can use epoll_wait to get ready fds. It should look like the following chart.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">                    app server</span><br><span class="line">       |---------------- |-------------------------|</span><br><span class="line">       |                 |epoll_ctl(add/del)       |</span><br><span class="line">       |epoll_create     |                         |epoll_wait</span><br><span class="line">       |                 |                         |</span><br><span class="line">       |    |-------------------|                  |</span><br><span class="line">       |    |     listen fd     |        |-----------------|</span><br><span class="line">|---------- |   read/write fd   |--------|       fd        |---------|</span><br><span class="line">|           |-------------------|        |-----------------|        |</span><br><span class="line">|               kernel                                              |</span><br><span class="line">|-------------------------------------------------------------------|</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">int listenfd = socket();</span><br><span class="line">bind(listenfd, addr);</span><br><span class="line">listen(listenfd);</span><br><span class="line">int efd = epoll_create(0);</span><br><span class="line">epoll_ctl(efd, epoll_ctrl_add, listenfd, &amp;ev);</span><br><span class="line">while(true) &#123;</span><br><span class="line">    epoll_event evs[size];</span><br><span class="line">    int nevent = epoll_wait(efd, evs, size, timeout);</span><br><span class="line">    for(int i; i&lt;nevent; i++) &#123;</span><br><span class="line">        if(e-&gt;fd==listenfd) &#123;</span><br><span class="line">            int fd = accept(listenfd);</span><br><span class="line">            epoll_ctl(efd, epoll_ctrl_add, fd, &amp;ev);</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">            read/write/logic</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Application use multiplxing to get ready fds (accpet/recvfrom/write) but the app needs to do the operation itself. It is the synchronize model (BIO, NIO, Multiplexing). Linux is hard to achieve AIO (asynchronize IO) considering OS safety (Windows use Iocp as AIO).</p>
<h5 id="Signal-driven"><a href="#Signal-driven" class="headerlink" title="Signal-driven"></a>Signal-driven</h5><h5 id="AIO"><a href="#AIO" class="headerlink" title="AIO"></a>AIO</h5><p>These two are not common used.</p>
</div><div class="tags"><a href="/tags/NIO/">NIO</a></div><div class="post-nav"><a class="pre" href="/2021/11/08/Dynamic-Programming/">Dynamic Programming</a><a class="next" href="/2020/07/31/rule-of-three/">The Rule of Three</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> Categories</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Algorithm/">Algorithm</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Android/">Android</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/C/">C++</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Design-Pattern/">Design Pattern</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Protocol/">Protocol</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/algorithm/">algorithm</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> Tags</i></div><div class="tagcloud"><a href="/tags/Polymorphism/" style="font-size: 15px;">Polymorphism</a> <a href="/tags/DP/" style="font-size: 15px;">DP</a> <a href="/tags/DIP/" style="font-size: 15px;">DIP</a> <a href="/tags/AOP/" style="font-size: 15px;">AOP</a> <a href="/tags/Annotation/" style="font-size: 15px;">Annotation</a> <a href="/tags/Interface/" style="font-size: 15px;">Interface</a> <a href="/tags/HashTable/" style="font-size: 15px;">HashTable</a> <a href="/tags/Mean-Shift/" style="font-size: 15px;">Mean Shift</a> <a href="/tags/OAuth/" style="font-size: 15px;">OAuth</a> <a href="/tags/View/" style="font-size: 15px;">View</a> <a href="/tags/TLS/" style="font-size: 15px;">TLS</a> <a href="/tags/Deep-copy/" style="font-size: 15px;">Deep copy</a> <a href="/tags/NIO/" style="font-size: 15px;">NIO</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> Links</i></div><ul></ul><a target="_blank"></a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer"><div><!--span#busuanzi_container_site_pv//span= ' '
//span#busuanzi_value_site_pv
//span(rel='nofollow')= ' ' + __(' HITS, ')--><span id="busuanzi_container_site_uv"><span id="busuanzi_value_site_uv"></span><span rel="nofollow">  VISITORS.</span></span></div>BINGYANG © 2021 刘冰洋 | HEADING TO THE FUTURE<br><a class="fa fa-github fa-2x" rel="nofollow" target="_blank" href="https://github.com/bbbbyang"></a> &nbsp; <a class="fa fa-linkedin fa-2x" rel="nofollow" target="_blank" href="https://www.linkedin.com/in/bingyang-liu-451b7976/"></a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.2.5/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.2.5/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script></div></body></html>